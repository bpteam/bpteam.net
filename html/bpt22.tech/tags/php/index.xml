<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>PHP on Evgen Pyanykh</title><link>//bpt22.tech/tags/php/</link><description>Recent content in PHP on Evgen Pyanykh</description><generator>Hugo -- gohugo.io</generator><language>ru</language><lastBuildDate>Sat, 17 Nov 2018 00:00:00 +0000</lastBuildDate><atom:link href="//bpt22.tech/tags/php/index.xml" rel="self" type="application/rss+xml"/><item><title>Пост анализ относительной даты создания документа с приведением к timestamp</title><link>//bpt22.tech/posts/2018-11-17-%D0%BF%D0%BE%D1%81%D1%82-%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7-%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%B4%D0%B0%D1%82%D1%8B-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0-%D1%81-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC-%D0%BA-timestamp/</link><pubDate>Sat, 17 Nov 2018 00:00:00 +0000</pubDate><guid>//bpt22.tech/posts/2018-11-17-%D0%BF%D0%BE%D1%81%D1%82-%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7-%D0%BE%D1%82%D0%BD%D0%BE%D1%81%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B9-%D0%B4%D0%B0%D1%82%D1%8B-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D1%8F-%D0%B4%D0%BE%D0%BA%D1%83%D0%BC%D0%B5%D0%BD%D1%82%D0%B0-%D1%81-%D0%BF%D1%80%D0%B8%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5%D0%BC-%D0%BA-timestamp/</guid><description>При сборе документов для анализа из открытых источников с дополнительной пост обработкой иногда нужно получить дату создания документа, но бывает так, что временная метка записана в человеко понятном формате в относительном виде и на не английском языке, в не структурированном виде. А документ мы пнинимает на обработку не во время получения скачивания.
Примеры входящих данных:
в понедельник, 14:33 две минуты назад вчера, 18:23 сегодня, 19:47 2018-11-17 18:22 Предварительный план Так как время призодит в разных языках и разных форматах, нам нужно привести несколько операций для понимания, того, что перед нами и в итоге получить Unix Timestamp.</description></item><item><title>GIT push во все зеркала репозитория</title><link>//bpt22.tech/posts/2016-03-21-git-push-%D0%B2%D0%BE-%D0%B2%D1%81%D0%B5-%D0%B7%D0%B5%D1%80%D0%BA%D0%B0%D0%BB%D0%B0-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F/</link><pubDate>Mon, 21 Mar 2016 00:00:00 +0000</pubDate><guid>//bpt22.tech/posts/2016-03-21-git-push-%D0%B2%D0%BE-%D0%B2%D1%81%D0%B5-%D0%B7%D0%B5%D1%80%D0%BA%D0%B0%D0%BB%D0%B0-%D1%80%D0%B5%D0%BF%D0%BE%D0%B7%D0%B8%D1%82%D0%BE%D1%80%D0%B8%D1%8F/</guid><description>Паранойя никогда не бывает избыточной, особенно для меня. Когда я пишу код и вдруг теряю его по разным причинам, не сохранился, заснул на бекспейсе, диск с git репозиторием посыпался, я всегда расстраиваюсь и не хочу писать снова, то что уже было написано. Ниже будет описано как предохраниться от одной из этих проблем, а именно с потерей данных по средствам гибели HDD. Мы реализуем кросс пуш во все возможные хранилища для того чтоб уберечь наши труды от забвения.</description></item><item><title>SPL VS процедуры и 5.6 VS 7 очередь (queue)</title><link>//bpt22.tech/posts/2016-02-15-spl-vs-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D1%8B-%D0%B8-5.6-vs-7-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C-queue/</link><pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate><guid>//bpt22.tech/posts/2016-02-15-spl-vs-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D1%8B-%D0%B8-5.6-vs-7-%D0%BE%D1%87%D0%B5%D1%80%D0%B5%D0%B4%D1%8C-queue/</guid><description>Рассмотрим структуры данных из стандартной библиотеки php (SPL) и процедурный подход с массивами. И замеряем скорость выполнения на разных версиях PHP, а именно на 5.6 и 7. Сегодняшняя тема: «структура Очередь».
Очередь — абстрактный тип данных с дисциплиной доступа к элементам «первый пришёл — первый вышел» (FIFO, First In — First Out). Добавление элемента (принято обозначать словом enqueue — поставить в очередь) возможно лишь в конец очереди, выборка — только из начала очереди (что принято называть словом dequeue — убрать из очереди), при этом выбранный элемент из очереди удаляется.</description></item><item><title>SPL VS процедуры и 5.6 VS 7 стек (stack)</title><link>//bpt22.tech/posts/2016-02-15-spl-vs-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D1%8B-%D0%B8-5.6-vs-7-%D1%81%D1%82%D0%B5%D0%BA-stack/</link><pubDate>Mon, 15 Feb 2016 00:00:00 +0000</pubDate><guid>//bpt22.tech/posts/2016-02-15-spl-vs-%D0%BF%D1%80%D0%BE%D1%86%D0%B5%D0%B4%D1%83%D1%80%D1%8B-%D0%B8-5.6-vs-7-%D1%81%D1%82%D0%B5%D0%BA-stack/</guid><description>Сегодня рассмотрим структуры данных из стандартной библиотеки php (SPL) и процедурный подход с массивами. И замеряем скорость выполнения на разных версиях PHP, а именно на 5.6 и 7. Начнем с простого, структура Стек.
Стек (англ. stack — стопка; читается стэк) — абстрактный тип данных, представляющий собой список элементов, организованных по принципу LIFO (англ. last in — first out, «последним пришёл — первым вышел»).
Чаще всего принцип работы стека сравнивают со стопкой тарелок: чтобы взять вторую сверху, нужно снять верхнюю.</description></item><item><title>Поиск номера телефона в тексте</title><link>//bpt22.tech/posts/2016-01-17-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D0%B0-%D1%82%D0%B5%D0%BB%D0%B5%D1%84%D0%BE%D0%BD%D0%B0-%D0%B2-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B5/</link><pubDate>Sun, 17 Jan 2016 00:00:00 +0000</pubDate><guid>//bpt22.tech/posts/2016-01-17-%D0%BF%D0%BE%D0%B8%D1%81%D0%BA-%D0%BD%D0%BE%D0%BC%D0%B5%D1%80%D0%B0-%D1%82%D0%B5%D0%BB%D0%B5%D1%84%D0%BE%D0%BD%D0%B0-%D0%B2-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B5/</guid><description>Однажды, когда мы работали над одним из проектов по сбору информации про риелторов и их активности на рынке, мой товарищ спросил меня: «Можем ли мы определять адрес квартиры по тексту автоматически?», тогда я не мог даже корректно обрабатывать номера телефонов в тексте, не то что адреса, на подобии: «Не далеко от кинотеатра ‘N&amp;rsquo;». Теперь, я наконец научился находить номера телефонов в тексте и приводить их в стандартный вид. Ниже я опишу как это сделать.</description></item><item><title>PHP класс для распознавания текста на изображении</title><link>//bpt22.tech/posts/2015-05-30-php-%D0%BA%D0%BB%D0%B0%D1%81%D1%81-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%B7%D0%BD%D0%B0%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0-%D0%BD%D0%B0-%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B8/</link><pubDate>Sat, 30 May 2015 00:00:00 +0000</pubDate><guid>//bpt22.tech/posts/2015-05-30-php-%D0%BA%D0%BB%D0%B0%D1%81%D1%81-%D0%B4%D0%BB%D1%8F-%D1%80%D0%B0%D1%81%D0%BF%D0%BE%D0%B7%D0%BD%D0%B0%D0%B2%D0%B0%D0%BD%D0%B8%D1%8F-%D1%82%D0%B5%D0%BA%D1%81%D1%82%D0%B0-%D0%BD%D0%B0-%D0%B8%D0%B7%D0%BE%D0%B1%D1%80%D0%B0%D0%B6%D0%B5%D0%BD%D0%B8%D0%B8/</guid><description>Для одного из проектов было необходимо распознать текст на изображении. Были варианты использования Tesseract, но была вероятность использования простого хостинга где не будет возможности установить дополнительный софт. Проанализировав доступные средства на GitHub нашел несколько реализаций, но они были на мой взгляд, то слишком сложные, то не простые для быстрой интеграции. В общем свой велосипед ближе и милей.
Класс поддерживает только текст написанный на монотонном фоне, без перемешивания строк. Такие изображения он не обработает:</description></item></channel></rss>